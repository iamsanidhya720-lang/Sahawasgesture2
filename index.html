<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gesture Zoom — Complete 3D Viewer</title>
  <meta name="theme-color" content="#000" />
  <style>
    :root{--bg:#000;--fg:#fff;--muted:#bdbdbd;--accent:#7aa2ff}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{background:var(--bg);color:var(--fg);font:500 15px/1.4 Inter,system-ui,Segoe UI,Roboto,Arial;display:flex;flex-direction:column}
    header{display:flex;align-items:center;justify-content:space-between;padding:10px 14px}
    .brand{display:flex;align-items:center;gap:10px}
    .dot{width:10px;height:10px;border-radius:999px;background:var(--accent);box-shadow:0 0 12px var(--accent)}
    .controls{display:flex;gap:8px;align-items:center}
    button,input[type=file]{appearance:none;border:1px solid #333;background:#111;color:var(--fg);padding:8px 12px;border-radius:10px;cursor:pointer}
    .wrap{flex:1;display:flex;flex-direction:column;gap:10px;width:100%;max-width:1200px;margin:0 auto;padding:0 10px 12px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;align-items:stretch}
    .panel{position:relative;border-radius:12px;overflow:hidden;background:#050505;outline:1px solid #141414;height:clamp(280px,62vh,760px)}
    .badge{position:absolute;left:10px;top:10px;font-size:12px;color:var(--muted);background:rgba(255,255,255,.04);padding:6px 8px;border-radius:999px;z-index:10}
    .toolbar{position:absolute;right:10px;top:10px;display:flex;gap:8px;z-index:5}
    canvas,img,video{display:block}
    #imgCanvas,#heartCanvas{width:100%;height:100%}
    #heartCanvas{display:none;background:#060606}
    .cameraWrap{position:relative;height:100%}
    video#cam{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;transform:scaleX(-1);background:#000}
    canvas#hud{position:absolute;inset:0;width:100%;height:100%;pointer-events:none}
    .meters{position:absolute;bottom:12px;left:12px;right:12px;display:flex;justify-content:space-between;gap:8px;font-weight:700}
    .chip{font-size:14px;color:#fff;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.12);padding:6px 10px;border-radius:999px}
    .tips{display:flex;gap:8px;flex-wrap:wrap;color:var(--muted);font-size:13px;padding:0 4px}
    .notice{color:var(--muted);text-align:center;font-size:13px}
    @media(max-width:900px){.grid{grid-template-columns:1fr}.panel{height:clamp(260px,42vh,560px)}}
    .loading{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.8);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:100}
    .loading-spinner{width:40px;height:40px;border:4px solid rgba(255,255,255,.3);border-radius:50%;border-top-color:#7aa2ff;animation:spin 1s ease-in-out infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
  </style>
</head>
<body>
  <!-- Loading overlay -->
  <div class="loading" id="loading">
    <div class="loading-spinner"></div>
    <p style="margin-top:20px">Initializing application...</p>
  </div>

  <header>
    <div class="brand"><span class="dot"></span><strong>Gesture Zoom 3D</strong></div>
    <div class="controls">
      <label for="file"> <input id="file" type="file" accept="image/*" style="display:none"> <span style="cursor:pointer">Upload Image</span> </label>
      <button id="reset">Reset View</button>
      <button id="flip">Flip Camera</button>
    </div>
  </header>

  <div class="wrap">
    <div class="grid">
      <!-- LEFT: Camera -->
      <section class="panel cameraWrap" id="camPanel">
        <span class="badge">Camera</span>
        <video id="cam" autoplay playsinline muted></video>
        <canvas id="hud"></canvas>
        <div class="meters">
          <div class="chip">Chaos: <span id="chaosVal">0.0</span></div>
          <div class="chip">Scale: <span id="scaleVal">1.00</span></div>
        </div>
      </section>

      <!-- RIGHT: Image canvas and 3D heart -->
      <section class="panel" id="imgPanel">
        <span class="badge" id="rightBadge">Image</span>
        <div class="toolbar">
          <button id="toggleHeart">Show 3D Heart</button>
          <button id="resetHeart" style="display:none">Reset Heart</button>
        </div>
        <canvas id="imgCanvas" width="1280" height="720"></canvas>
        <canvas id="heartCanvas"></canvas>
      </section>
    </div>

    <div class="tips">
      <div>• <strong>Pinch/Spread</strong> with both index fingertips to zoom the image/heart.</div>
      <div>• Move midpoint while pinched to <strong>pan</strong>.</div>
      <div>• One-hand index—thumb pinch toggles <strong>drag</strong> mode for image/heart.</div>
      <div>• 3D: drag to orbit, wheel to zoom (mouse) or pinch to zoom (touch).</div>
      <div>• let's talk - sanidhya.bt</div>

    </div>
    <p class="notice">Sanidhya <3</p>
  </div>

  <!-- MediaPipe libraries -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>

  <script>
  /* ====================== INITIALIZATION ====================== */
  document.addEventListener('DOMContentLoaded', async () => {
    try {
      // DOM references
      const loadingEl = document.getElementById('loading');
      const fileInput = document.getElementById('file');
      const resetBtn = document.getElementById('reset');
      const flipBtn = document.getElementById('flip');
      const toggleHeartBtn = document.getElementById('toggleHeart');
      const resetHeartBtn = document.getElementById('resetHeart');
      const rightBadge = document.getElementById('rightBadge');
      const imgCanvas = document.getElementById('imgCanvas'); 
      const imgCtx = imgCanvas.getContext('2d');
      const heartCanvas = document.getElementById('heartCanvas');
      const heartCtx = heartCanvas.getContext('2d');
      const cam = document.getElementById('cam'); 
      const camPanel = document.getElementById('camPanel');
      const hud = document.getElementById('hud'); 
      const hudCtx = hud.getContext('2d');
      const chaosEl = document.getElementById('chaosVal'); 
      const scaleEl = document.getElementById('scaleVal');
      const imgPanel = document.getElementById('imgPanel');

      /* ====================== IMAGE STATE & DRAW ====================== */
      const imgState = { 
        img: new Image(), 
        loaded: false, 
        scale: 1, 
        minScale: 0.3, 
        maxScale: 6, 
        x: 0, 
        y: 0 
      };

      function fitImage() {
        if (!imgState.loaded) return;
        const cw = imgCanvas.width, ch = imgCanvas.height;
        const iw = imgState.img.naturalWidth || 1, ih = imgState.img.naturalHeight || 1;
        const scale = Math.min(cw / iw, ch / ih);
        imgState.scale = scale;
        imgState.x = cw / 2;
        imgState.y = ch / 2;
        drawImage();
      }

      function drawImage() {
        const { img, scale, x, y } = imgState;
        imgCtx.setTransform(1, 0, 0, 1, 0, 0);
        imgCtx.clearRect(0, 0, imgCanvas.width, imgCanvas.height);
        
        if (!imgState.loaded) {
          imgCtx.fillStyle = '#0a0a0a';
          imgCtx.fillRect(0, 0, imgCanvas.width, imgCanvas.height);
          imgCtx.fillStyle = '#666';
          imgCtx.font = '600 16px Inter, sans-serif';
          imgCtx.textAlign = 'center';
          imgCtx.fillText('Upload an image to begin', imgCanvas.width / 2, imgCanvas.height / 2);
          return;
        }
        
        imgCtx.translate(x, y);
        imgCtx.scale(scale, scale);
        imgCtx.drawImage(img, -img.naturalWidth / 2, -img.naturalHeight / 2);
      }

      /* ====================== 3D HEART STATE ====================== */
      const heart3D = {
        active: false,
        scale: 1,
        rotation: { x: 0, y: 0, z: 0 },
        position: { x: 0, y: 0, z: 0 },
        autoRotate: true,
        minScale: 0.5,
        maxScale: 3
      };

      function drawHeart3D() {
        if (!heart3D.active) return;
        
        const ctx = heartCtx;
        const w = heartCanvas.width;
        const h = heartCanvas.height;
        const cx = w / 2;
        const cy = h / 2;
        
        // Clear canvas
        ctx.fillStyle = '#060606';
        ctx.fillRect(0, 0, w, h);
        
        // Apply transforms
        ctx.save();
        ctx.translate(cx + heart3D.position.x, cy + heart3D.position.y);
        ctx.scale(heart3D.scale, heart3D.scale);
        
        // Draw 3D-looking heart with multiple layers for depth
        const layers = 8;
        for (let i = 0; i < layers; i++) {
          const depth = i / layers;
          const offset = depth * 10;
          const alpha = 1 - depth * 0.7;
          
          ctx.save();
          ctx.translate(-offset, -offset);
          ctx.rotate(heart3D.rotation.z + depth * 0.1);
          
          // Create heart path
          ctx.beginPath();
          const scale = 60 + depth * 20;
          
          // Mathematical heart curve
          for (let t = 0; t <= Math.PI * 2; t += 0.1) {
            const x = scale * (16 * Math.pow(Math.sin(t), 3)) / 16;
            const y = -scale * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) / 16;
            
            if (t === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.closePath();
          
          // Gradient fill for 3D effect
          const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, scale);
          if (i === 0) {
            gradient.addColorStop(0, `rgba(255, 51, 102, ${alpha})`);
            gradient.addColorStop(0.5, `rgba(255, 17, 68, ${alpha})`);
            gradient.addColorStop(1, `rgba(139, 0, 34, ${alpha})`);
          } else {
            gradient.addColorStop(0, `rgba(255, 102, 153, ${alpha * 0.6})`);
            gradient.addColorStop(1, `rgba(76, 0, 19, ${alpha * 0.3})`);
          }
          
          ctx.fillStyle = gradient;
          ctx.fill();
          
          // Stroke for definition
          if (i === 0) {
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.3})`;
            ctx.lineWidth = 2;
            ctx.stroke();
          }
          
          ctx.restore();
        }
        
        // Add sparkle effect
        for (let i = 0; i < 20; i++) {
          const angle = (Date.now() * 0.001 + i) * 0.5;
          const radius = 80 + Math.sin(angle) * 20;
          const x = Math.cos(angle * 2) * radius;
          const y = Math.sin(angle * 2) * radius;
          
          ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + 0.3 * Math.sin(angle * 3)})`;
          ctx.beginPath();
          ctx.arc(x, y, 2, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
        
        // Auto-rotate when not being manipulated
        if (heart3D.autoRotate && !gesture.haveTwo && !gesture.havePinch) {
          heart3D.rotation.z += 0.02;
        }
      }

      function animateHeart() {
        if (heart3D.active) {
          drawHeart3D();
          requestAnimationFrame(animateHeart);
        }
      }

      /* ====================== RESIZE HANDLING ====================== */
      function sizeCanvases() {
        const ir = imgPanel.getBoundingClientRect();
        const scale = Math.min(window.devicePixelRatio || 1, 2);
        
        imgCanvas.width = Math.max(2, Math.floor(ir.width * scale));
        imgCanvas.height = Math.max(2, Math.floor(ir.height * scale));
        imgCanvas.style.width = Math.floor(ir.width) + 'px';
        imgCanvas.style.height = Math.floor(ir.height) + 'px';

        heartCanvas.width = Math.max(2, Math.floor(ir.width * scale));
        heartCanvas.height = Math.max(2, Math.floor(ir.height * scale));
        heartCanvas.style.width = Math.floor(ir.width) + 'px';
        heartCanvas.style.height = Math.floor(ir.height) + 'px';

        const cr = camPanel.getBoundingClientRect();
        hud.width = Math.max(2, Math.floor(cr.width * scale));
        hud.height = Math.max(2, Math.floor(cr.height * scale));
        hud.style.width = Math.floor(cr.width) + 'px';
        hud.style.height = Math.floor(cr.height) + 'px';

        imgCtx.setTransform(scale, 0, 0, scale, 0, 0);
        hudCtx.setTransform(scale, 0, 0, scale, 0, 0);

        drawImage();
        if (heart3D.active) drawHeart3D();
      }

      window.addEventListener('resize', sizeCanvases);
      window.addEventListener('orientationchange', sizeCanvases);

      /* ====================== IMAGE UPLOAD ====================== */
      fileInput.addEventListener('change', e => {
        const f = e.target.files?.[0];
        if (!f) return;
        
        const r = new FileReader();
        r.onload = ev => {
          imgState.img.onload = () => {
            imgState.loaded = true;
            sizeCanvases();
            fitImage();
          };
          imgState.img.src = ev.target.result;
        };
        r.readAsDataURL(f);
      });

      /* ====================== MOUSE/TOUCH FALLBACK ====================== */
      let isDragging = false, last = { x: 0, y: 0 };
      
      function handleWheel(e) {
        if (heart3D.active) {
          e.preventDefault();
          const delta = -Math.sign(e.deltaY) * 0.1;
          heart3D.scale = Math.max(heart3D.minScale, Math.min(heart3D.maxScale, heart3D.scale * (1 + delta)));
          scaleEl.textContent = heart3D.scale.toFixed(2);
          drawHeart3D();
        } else if (imgState.loaded) {
          e.preventDefault();
          const delta = -Math.sign(e.deltaY) * 0.08;
          const pre = imgState.scale;
          imgState.scale = Math.max(imgState.minScale, Math.min(imgState.maxScale, imgState.scale * (1 + delta)));
          const rect = imgCanvas.getBoundingClientRect();
          const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
          const k = imgState.scale / pre;
          imgState.x = cx - (cx - imgState.x) * k;
          imgState.y = cy - (cy - imgState.y) * k;
          scaleEl.textContent = imgState.scale.toFixed(2);
          drawImage();
        }
      }

      imgCanvas.addEventListener('wheel', handleWheel, { passive: false });
      heartCanvas.addEventListener('wheel', handleWheel, { passive: false });

      function handlePointerDown(e) {
        isDragging = true;
        last = { x: e.clientX, y: e.clientY };
        const canvas = heart3D.active ? heartCanvas : imgCanvas;
        canvas.setPointerCapture && canvas.setPointerCapture(e.pointerId);
      }

      function handlePointerMove(e) {
        if (!isDragging) return;
        const dx = e.clientX - last.x, dy = e.clientY - last.y;
        
        if (heart3D.active) {
          heart3D.rotation.z += dx * 0.01;
          heart3D.position.x += dx * 0.5;
          heart3D.position.y += dy * 0.5;
          drawHeart3D();
        } else {
          imgState.x += dx;
          imgState.y += dy;
          drawImage();
        }
        
        last = { x: e.clientX, y: e.clientY };
      }

      imgCanvas.addEventListener('pointerdown', handlePointerDown);
      heartCanvas.addEventListener('pointerdown', handlePointerDown);
      imgCanvas.addEventListener('pointermove', handlePointerMove);
      heartCanvas.addEventListener('pointermove', handlePointerMove);
      addEventListener('pointerup', () => isDragging = false);

      /* ====================== BUTTON CONTROLS ====================== */
      resetBtn.addEventListener('click', () => {
        if (heart3D.active) {
          heart3D.scale = 1;
          heart3D.rotation = { x: 0, y: 0, z: 0 };
          heart3D.position = { x: 0, y: 0, z: 0 };
          drawHeart3D();
          scaleEl.textContent = '1.00';
        } else {
          fitImage();
          scaleEl.textContent = imgState.scale.toFixed(2);
        }
        chaosFilter.reset();
        chaosEl.textContent = '0.0';
      });

      let useFront = true;
      flipBtn.addEventListener('click', () => {
        useFront = !useFront;
        cam.style.transform = useFront ? 'scaleX(-1)' : 'scaleX(1)';
        startCamera();
      });

      /* ====================== HEART CONTROLS ====================== */
      toggleHeartBtn.addEventListener('click', () => {
        heart3D.active = !heart3D.active;
        
        if (heart3D.active) {
          heartCanvas.style.display = 'block';
          imgCanvas.style.display = 'none';
          rightBadge.textContent = '3D Heart';
          toggleHeartBtn.textContent = 'Show Image';
          resetHeartBtn.style.display = 'inline-block';
          animateHeart();
        } else {
          heartCanvas.style.display = 'none';
          imgCanvas.style.display = 'block';
          rightBadge.textContent = 'Image';
          toggleHeartBtn.textContent = 'Show 3D Heart';
          resetHeartBtn.style.display = 'none';
        }
      });

      resetHeartBtn.addEventListener('click', () => {
        heart3D.scale = 1;
        heart3D.rotation = { x: 0, y: 0, z: 0 };
        heart3D.position = { x: 0, y: 0, z: 0 };
        drawHeart3D();
        scaleEl.textContent = '1.00';
      });

      /* ====================== MEDIAPIPE HANDS + CAMERA ====================== */
      let mediaCamera = null, hands = null;
      
      function setupHands() {
        hands = new Hands({ 
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` 
        });
        hands.setOptions({ 
          maxNumHands: 2, 
          modelComplexity: 1, 
          minDetectionConfidence: 0.6, 
          minTrackingConfidence: 0.6 
        });
        hands.onResults(onHands);
      }

      async function startCamera() {
        try {
          if (mediaCamera) {
            await mediaCamera.stop();
            mediaCamera = null;
          }
          
          const constraints = { 
            audio: false, 
            video: { 
              facingMode: useFront ? 'user' : 'environment', 
              width: { ideal: 1280 }, 
              height: { ideal: 720 } 
            } 
          };
          
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          cam.srcObject = stream;
          cam.onloadedmetadata = () => cam.play();
          
          if (!hands) setupHands();
          
          mediaCamera = new Camera(cam, { 
            onFrame: async () => {
              try {
                await hands.send({ image: cam });
              } catch (e) {}
            }, 
            width: 1280, 
            height: 720 
          });
          
          mediaCamera.start();
        } catch (err) {
          console.warn('Camera unavailable', err);
          hudCtx.clearRect(0, 0, hud.width, hud.height);
          hudCtx.fillStyle = '#222';
          hudCtx.fillRect(20, 20, hud.width / 2, 60);
          hudCtx.fillStyle = '#fff';
          hudCtx.font = '14px sans-serif';
          hudCtx.fillText('Camera unavailable — allow permissions or close other apps using it.', 30, 60);
        }
      }

      /* ====================== GESTURE LOGIC ====================== */
      const smooth = (p, n, a) => p + (n - p) * a;
      const clamp = (v, mn, mx) => Math.max(mn, Math.min(mx, v));
      
      const gesture = { 
        haveTwo: false, 
        havePinch: false, 
        baseDist: 0, 
        baseScale: 1, 
        lastMid: { x: 0, y: 0 }, 
        mid: { x: 0, y: 0 }
      };
      
      const chaosFilter = (() => {
        let last = null, ema = 0;
        return {
          update(p) {
            if (!last) {
              last = p;
              return 0;
            }
            const d = Math.hypot(p.x - last.x, p.y - last.y);
            last = p;
            ema = smooth(ema, d, 0.2);
            return ema;
          },
          reset() {
            ema = 0;
            last = null;
          }
        };
      })();

      function canvasPointFromNorm(nx, ny, canvasEl) {
        const r = canvasEl.getBoundingClientRect();
        return { x: (1 - nx) * r.width, y: ny * r.height };
      }

      function onHands(results) {
        hudCtx.clearRect(0, 0, hud.width, hud.height);
        const lm = results.multiHandLandmarks || [];
        const tips = [];
        
        lm.forEach(h => {
          drawHandHUD(h);
          tips.push({ index: h[8], thumb: h[4] });
        });

        // Two-hand pinch to zoom & midpoint pan
        if (tips.length >= 2) {
          const a = tips[0].index, b = tips[1].index;
          gesture.haveTwo = true;
          const dx = a.x - b.x, dy = a.y - b.y;
          const dist = Math.hypot(dx, dy);
          const mid = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
          chaosEl.textContent = chaosFilter.update(mid).toFixed(2);

          if (gesture.baseDist === 0) {
            gesture.baseDist = dist;
            gesture.baseScale = heart3D.active ? heart3D.scale : imgState.scale;
            gesture.lastMid = mid;
          } else {
            const factor = dist / gesture.baseDist;
            
            if (heart3D.active) {
              // Handle 3D heart zoom and rotation
              heart3D.scale = clamp(gesture.baseScale * factor, heart3D.minScale, heart3D.maxScale);
              
              // Handle rotation based on midpoint movement
              const deltaX = (mid.x - gesture.lastMid.x) * 5;
              const deltaY = (mid.y - gesture.lastMid.y) * 5;
              heart3D.rotation.z += deltaX;
              heart3D.position.y += deltaY * heartCanvas.height * 0.3;
              
              scaleEl.textContent = heart3D.scale.toFixed(2);
              drawHeart3D();
              
            } else {
              // Handle image zoom and pan (original logic)
              const nextScale = clamp(gesture.baseScale * factor, imgState.minScale, imgState.maxScale);
              const m = canvasPointFromNorm(mid.x, mid.y, hud);
              const rect = imgCanvas.getBoundingClientRect();
              const cx = (m.x / hud.width) * rect.width;
              const cy = (m.y / hud.height) * rect.height;
              const pre = imgState.scale;
              imgState.scale = smooth(pre, nextScale, 0.4);
              const k = imgState.scale / pre;
              imgState.x = cx - (cx - imgState.x) * k;
              imgState.y = cy - (cy - imgState.y) * k;
              imgState.x += (mid.x - gesture.lastMid.x) * rect.width * 0.7;
              imgState.y += (mid.y - gesture.lastMid.y) * rect.height * 0.7;
              drawImage();
              scaleEl.textContent = imgState.scale.toFixed(2);
            }
            
            gesture.lastMid = mid;
          }
        } else {
          gesture.haveTwo = false;
          gesture.baseDist = 0;
        }

        // One-hand pinch -> drag mode
        if (tips.length === 1) {
          const t = tips[0];
          const pinch = Math.hypot(t.index.x - t.thumb.x, t.index.y - t.thumb.y) < 0.06;
          
          if (pinch && !gesture.havePinch) {
            gesture.havePinch = true;
            gesture.mid = { x: t.index.x, y: t.index.y };
            heart3D.autoRotate = false;
          } else if (pinch && gesture.havePinch) {
            const nx = t.index.x, ny = t.index.y;
            
            if (heart3D.active) {
              // Handle 3D heart single-hand rotation
              const deltaX = (nx - gesture.mid.x) * 3;
              const deltaY = (ny - gesture.mid.y) * 3;
              heart3D.rotation.z += deltaX;
              heart3D.position.x += deltaX * heartCanvas.width * 0.2;
              heart3D.position.y += deltaY * heartCanvas.height * 0.2;
              drawHeart3D();
            } else {
              // Handle image single-hand pan (original logic)
              imgState.x += (nx - gesture.mid.x) * imgCanvas.width;
              imgState.y += (ny - gesture.mid.y) * imgCanvas.height;
              drawImage();
            }
            
            gesture.mid = { x: nx, y: ny };
          } else {
            gesture.havePinch = false;
            heart3D.autoRotate = true;
          }
        }
      }

      function drawHandHUD(hand) {
        const W = hud.width / (Math.min(window.devicePixelRatio || 1, 2));
        const H = hud.height / (Math.min(window.devicePixelRatio || 1, 2));
        
        function P(p) {
          return { x: (1 - p.x) * W, y: p.y * H };
        }
        
        hudCtx.strokeStyle = 'rgba(255,255,255,.12)';
        hudCtx.lineWidth = 2;
        
        const bones = [[0,1,2,3,4],[0,5,6,7,8],[0,9,10,11,12],[0,13,14,15,16],[0,17,18,19,20]];
        
        bones.forEach(chain => {
          hudCtx.beginPath();
          chain.forEach((i, j) => {
            const pt = P(hand[i]);
            if (j === 0) hudCtx.moveTo(pt.x, pt.y);
            else hudCtx.lineTo(pt.x, pt.y);
          });
          hudCtx.stroke();
        });
        
        [hand[8], hand[4]].forEach(pt => {
          const p = P(pt);
          const r = 10;
          const g = hudCtx.createRadialGradient(p.x, p.y, 1, p.x, p.y, r * 2);
          g.addColorStop(0, 'rgba(122,162,255,.95)');
          g.addColorStop(1, 'rgba(122,162,255,0)');
          hudCtx.fillStyle = g;
          hudCtx.beginPath();
          hudCtx.arc(p.x, p.y, r * 2, 0, Math.PI * 2);
          hudCtx.fill();
          hudCtx.fillStyle = '#fff';
          hudCtx.beginPath();
          hudCtx.arc(p.x, p.y, 4, 0, Math.PI * 2);
          hudCtx.fill();
        });
      }

      /* ====================== INITIALIZATION ====================== */
      sizeCanvases();
      drawImage();
      
      try {
        await startCamera();
      } catch (e) {
        console.warn('Camera start failed', e);
      }
      
      // Hide loading screen after everything is ready
      setTimeout(() => {
        loadingEl.style.display = 'none';
      }, 1000);
      
      console.log('App fully initialized');
    } catch (error) {
      console.error('Initialization error:', error);
      document.getElementById('loading').innerHTML = `
        <p style="color:#ff5555;text-align:center">Initialization failed</p>
        <p style="color:#aaa;font-size:14px">${error.message}</p>
        <button onclick="window.location.reload()" style="margin-top:20px;background:#333;color:#fff;border:none;padding:10px 20px;border-radius:5px;cursor:pointer">Reload</button>
      `;
    }
  });
  </script>
</body>
</html>
