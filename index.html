<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gesture Zoom — Image + Camera + 3D Heart (All-in-one)</title>
  <meta name="theme-color" content="#000" />
  <style>
    :root{--bg:#000;--fg:#fff;--muted:#bdbdbd;--accent:#7aa2ff}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{background:var(--bg);color:var(--fg);font:500 15px/1.4 Inter,system-ui,Segoe UI,Roboto,Arial;display:flex;flex-direction:column}
    header{display:flex;align-items:center;justify-content:space-between;padding:10px 14px}
    .brand{display:flex;align-items:center;gap:10px}
    .dot{width:10px;height:10px;border-radius:999px;background:var(--accent);box-shadow:0 0 12px var(--accent)}
    .controls{display:flex;gap:8px;align-items:center}
    button,input[type=file]{appearance:none;border:1px solid #333;background:#111;color:var(--fg);padding:8px 12px;border-radius:10px;cursor:pointer}
    .wrap{flex:1;display:flex;flex-direction:column;gap:10px;width:100%;max-width:1200px;margin:0 auto;padding:0 10px 12px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;align-items:stretch}
    .panel{position:relative;border-radius:12px;overflow:hidden;background:#050505;outline:1px solid #141414;height:clamp(280px,62vh,760px)}
    .badge{position:absolute;left:10px;top:10px;font-size:12px;color:var(--muted);background:rgba(255,255,255,.04);padding:6px 8px;border-radius:999px}
    .toolbar{position:absolute;right:10px;top:10px;display:flex;gap:8px;z-index:5}
    canvas,img,video{display:block}
    #imgCanvas,#heartCanvas{width:100%;height:100%}
    #heartCanvas{display:none;background:#060606}
    .cameraWrap{position:relative;height:100%}
    video#cam{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;transform:scaleX(-1);background:#000}
    canvas#hud{position:absolute;inset:0;width:100%;height:100%;pointer-events:none}
    .meters{position:absolute;bottom:12px;left:12px;right:12px;display:flex;justify-content:space-between;gap:8px;font-weight:700}
    .chip{font-size:14px;color:#fff;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.12);padding:6px 10px;border-radius:999px}
    .tips{display:flex;gap:8px;flex-wrap:wrap;color:var(--muted);font-size:13px;padding:0 4px}
    .notice{color:var(--muted);text-align:center;font-size:13px}
    .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.6);backdrop-filter:blur(2px);z-index:6}
    .overlay .box{max-width:520px;padding:14px 16px;border:1px solid #333;border-radius:12px;background:#0b0b0b;color:#ddd;font-size:14px;line-height:1.5}
    @media(max-width:900px){.grid{grid-template-columns:1fr}.panel{height:clamp(260px,42vh,560px)}}
  </style>

  <!-- MediaPipe libs (non-module) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>
</head>
<body>
<header>
  <div class="brand"><span class="dot"></span><strong>Gesture Zoom</strong></div>
  <div class="controls">
    <label for="file"> <input id="file" type="file" accept="image/*" style="display:none"> <span style="cursor:pointer">Upload Image</span> </label>
    <button id="reset">Reset View</button>
    <button id="flip">Flip Camera</button>
  </div>
</header>

<div class="wrap">
  <div class="grid">
    <!-- LEFT: Camera -->
    <section class="panel cameraWrap" id="camPanel">
      <span class="badge">Camera</span>
      <video id="cam" autoplay playsinline muted></video>
      <canvas id="hud"></canvas>
      <div class="overlay" id="insecure">
        <div class="box">
          <strong>Camera needs a secure context (https or localhost).</strong><br/>
          Open this file via a local server (e.g. VS Code “Live Server”) or deploy to https. The rest of the page still works without camera.
        </div>
      </div>
      <div class="meters">
        <div class="chip">Chaos: <span id="chaosVal">0.0</span></div>
        <div class="chip">Scale: <span id="scaleVal">1.00</span></div>
      </div>
    </section>

    <!-- RIGHT: Image canvas and 3D heart -->
    <section class="panel" id="imgPanel">
      <span class="badge" id="rightBadge">Image</span>
      <div class="toolbar">
        <button id="toggleHeart">Show 3D Heart</button>
        <button id="resetHeart" style="display:none">Reset Heart</button>
      </div>
      <canvas id="imgCanvas" width="1280" height="720"></canvas>
      <canvas id="heartCanvas"></canvas>
    </section>
  </div>

  <div class="tips">
    <div>• <strong>Pinch/Spread</strong> with both index fingertips to zoom the image.</div>
    <div>• Move midpoint while pinched to <strong>pan</strong>.</div>
    <div>• One-hand index–thumb pinch toggles <strong>drag</strong> mode for image.</div>
    <div>• 3D: drag to orbit, wheel to zoom (mouse) or pinch to zoom (touch).</div>
  </div>
  <p class="notice">All processing runs in your browser. Nothing leaves your device.</p>
</div>

<!-- Single-module script: imports THREE + OrbitControls and contains app code -->
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/controls/OrbitControls.js';

// Expose for debugging if needed
window.THREE = THREE;
window.OrbitControls = OrbitControls;

/* ====================== DOM refs ====================== */
const fileInput = document.getElementById('file');
const resetBtn = document.getElementById('reset');
const flipBtn = document.getElementById('flip');
const toggleHeartBtn = document.getElementById('toggleHeart');
const resetHeartBtn = document.getElementById('resetHeart');
const rightBadge = document.getElementById('rightBadge');
const imgCanvas = document.getElementById('imgCanvas'); const imgCtx = imgCanvas.getContext('2d');
const heartCanvas = document.getElementById('heartCanvas');
const cam = document.getElementById('cam'); const camPanel = document.getElementById('camPanel');
const hud = document.getElementById('hud'); const hudCtx = hud.getContext('2d');
const chaosEl = document.getElementById('chaosVal'); const scaleEl = document.getElementById('scaleVal');
const imgPanel = document.getElementById('imgPanel');
const insecureOverlay = document.getElementById('insecure');

/* ====================== Image state & draw ====================== */
const imgState = { img:new Image(), loaded:false, scale:1, minScale:.3, maxScale:6, x:0, y:0 };
function fitImage(){ if(!imgState.loaded) return; const cw=imgCanvas.width, ch=imgCanvas.height; const iw=imgState.img.naturalWidth||1, ih=imgState.img.naturalHeight||1; const scale=Math.min(cw/iw,ch/ih); imgState.scale=scale; imgState.x=cw/2; imgState.y=ch/2; drawImage(); }
function drawImage(){ const {img,scale,x,y}=imgState; // reset transform & clear
  imgCtx.setTransform(1,0,0,1,0,0); imgCtx.clearRect(0,0,imgCanvas.width,imgCanvas.height);
  if(!imgState.loaded){ imgCtx.fillStyle='#0a0a0a'; imgCtx.fillRect(0,0,imgCanvas.width,imgCanvas.height); imgCtx.fillStyle='#666'; imgCtx.font='600 16px Inter, sans-serif'; imgCtx.textAlign='center'; imgCtx.fillText('Upload an image to begin', imgCanvas.width/2, imgCanvas.height/2); return; }
  imgCtx.translate(x,y); imgCtx.scale(scale,scale); imgCtx.drawImage(img,-img.naturalWidth/2,-img.naturalHeight/2);
}

/* ====================== Resize handling ====================== */
function sizeCanvases(){
  const ir = imgPanel.getBoundingClientRect();
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  imgCanvas.width = Math.max(2, Math.floor(ir.width * dpr));
  imgCanvas.height = Math.max(2, Math.floor(ir.height * dpr));
  imgCanvas.style.width = Math.floor(ir.width) + 'px';
  imgCanvas.style.height = Math.floor(ir.height) + 'px';
  heartCanvas.width = Math.max(2, Math.floor(ir.width * dpr));
  heartCanvas.height = Math.max(2, Math.floor(ir.height * dpr));
  heartCanvas.style.width = Math.floor(ir.width) + 'px';
  heartCanvas.style.height = Math.floor(ir.height) + 'px';
  const cr = camPanel.getBoundingClientRect();
  hud.width = Math.max(2, Math.floor(cr.width * dpr));
  hud.height = Math.max(2, Math.floor(cr.height * dpr));
  hud.style.width = Math.floor(cr.width) + 'px';
  hud.style.height = Math.floor(cr.height) + 'px';
  imgCtx.setTransform(dpr,0,0,dpr,0,0);
  hudCtx.setTransform(dpr,0,0,dpr,0,0);
  drawImage();
  if(window.heart3D && window.heart3D.onResize){
    window.heart3D.onResize(ir.width, ir.height);
  }
}
window.addEventListener('resize', sizeCanvases);
window.addEventListener('orientationchange', sizeCanvases);

/* ====================== Upload ====================== */
fileInput.addEventListener('change', e=>{ const f=e.target.files?.[0]; if(!f) return; const r=new FileReader(); r.onload = ev=>{ imgState.img.onload = ()=>{ imgState.loaded = true; sizeCanvases(); fitImage(); }; imgState.img.src = ev.target.result; }; r.readAsDataURL(f); });

/* ====================== Mouse/touch fallback ====================== */
let isDragging=false, last={x:0,y:0};
imgCanvas.addEventListener('wheel', e=>{ if(!imgState.loaded) return; e.preventDefault(); const delta = -Math.sign(e.deltaY)*0.08; const pre = imgState.scale; imgState.scale = Math.max(imgState.minScale, Math.min(imgState.maxScale, imgState.scale*(1+delta))); const rect = imgCanvas.getBoundingClientRect(); const cx = e.clientX-rect.left, cy = e.clientY-rect.top; const k = imgState.scale/pre; imgState.x = cx - (cx-imgState.x)*k; imgState.y = cy - (cy-imgState.y)*k; scaleEl.textContent = imgState.scale.toFixed(2); drawImage(); }, {passive:false});
imgCanvas.addEventListener('pointerdown', e=>{ isDragging=true; last={x:e.clientX,y:e.clientY}; imgCanvas.setPointerCapture && imgCanvas.setPointerCapture(e.pointerId); });
imgCanvas.addEventListener('pointermove', e=>{ if(!isDragging) return; const dx=e.clientX-last.x, dy=e.clientY-last.y; imgState.x += dx; imgState.y += dy; last={x:e.clientX,y:e.clientY}; drawImage(); });
addEventListener('pointerup', ()=>isDragging=false);

/* ====================== Buttons ====================== */
resetBtn.addEventListener('click', ()=>{ fitImage(); chaosFilter.reset(); chaosEl.textContent='0.0'; scaleEl.textContent=imgState.scale.toFixed(2); });
let useFront=true;
flipBtn.addEventListener('click', ()=>{ useFront=!useFront; if(useFront) cam.style.transform = 'scaleX(-1)'; else cam.style.transform = 'scaleX(1)'; startCamera(); });

/* ====================== MediaPipe Hands + Camera ====================== */
let mediaCamera=null, hands=null;
function setupHands(){
  hands = new Hands({ locateFile: (file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
  hands.setOptions({ maxNumHands:2, modelComplexity:1, minDetectionConfidence:0.6, minTrackingConfidence:0.6 });
  hands.onResults(onHands);
}
async function startCamera(){
  try{
    if(!isSecureContext){
      insecureOverlay.style.display = 'flex';
      throw new Error('Insecure context');
    } else {
      insecureOverlay.style.display = 'none';
    }
    if(mediaCamera){ await mediaCamera.stop(); mediaCamera=null; }
    const constraints = { audio:false, video:{ facingMode: useFront ? 'user' : 'environment', width:{ideal:1280}, height:{ideal:720} } };
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    cam.srcObject = stream;
    cam.onloadedmetadata = ()=> cam.play();
    if(!hands) setupHands();
    mediaCamera = new Camera(cam, { onFrame: async ()=> { try{ await hands.send({image: cam}); }catch(e){} }, width: 1280, height: 720 });
    mediaCamera.start();
  }catch(err){
    console.warn('Camera unavailable', err);
    hudCtx.clearRect(0,0,hud.width,hud.height);
    hudCtx.fillStyle = '#222';
    hudCtx.fillRect(20,20, Math.min(520, hud.width-40), 64);
    hudCtx.fillStyle = '#fff';
    hudCtx.font = '14px sans-serif';
    const msg = isSecureContext ? 'Camera unavailable — allow camera permissions or close other apps using it.' : 'Open over https or localhost to enable camera.';
    hudCtx.fillText(msg, 30, 60);
  }
}

/* ====================== Gesture logic ====================== */
const smooth=(p,n,a)=>p+(n-p)*a;
const clamp=(v,mn,mx)=>Math.max(mn,Math.min(mx,v));
const gesture = { haveTwo:false, havePinch:false, baseDist:0, baseScale:1, lastMid:{x:0,y:0}, mid:{x:0,y:0} };
const chaosFilter = (function(){ let last=null, ema=0; return { update(p){ if(!last){ last=p; return 0 } const d=Math.hypot(p.x-last.x,p.y-last.y); last=p; ema = smooth(ema,d,0.2); return ema; }, reset(){ ema=0; last=null } }; })();
function canvasPointFromNorm(nx,ny,canvasEl){ const r = canvasEl.getBoundingClientRect(); return { x:(1-nx)*r.width, y: ny*r.height }; }

function onHands(results){
  hudCtx.clearRect(0,0,hud.width, hud.height);
  const lm = results.multiHandLandmarks||[];
  const tips=[];
  lm.forEach(h=>{ drawHandHUD(h); tips.push({ index:h[8], thumb:h[4] }); });

  if(tips.length>=2){
    const a=tips[0].index, b=tips[1].index;
    gesture.haveTwo=true;
    const dx=a.x-b.x, dy=a.y-b.y;
    const dist=Math.hypot(dx,dy);
    const mid = {x:(a.x+b.x)/2, y:(a.y+b.y)/2};
    chaosEl.textContent = chaosFilter.update(mid).toFixed(2);

    if(gesture.baseDist===0){
      gesture.baseDist=dist;
      gesture.baseScale=imgState.scale;
      gesture.lastMid=mid;
    } else {
      const factor = dist/gesture.baseDist;
      const nextScale = clamp(gesture.baseScale*factor, imgState.minScale, imgState.maxScale);
      const m = canvasPointFromNorm(mid.x, mid.y, hud);
      const rect = imgCanvas.getBoundingClientRect();
      const cx = (m.x/hud.width)*rect.width;
      const cy = (m.y/hud.height)*rect.height;
      const pre=imgState.scale;
      imgState.scale = smooth(pre, nextScale, 0.4);
      const k = imgState.scale/pre;
      imgState.x = cx - (cx-imgState.x)*k;
      imgState.y = cy - (cy-imgState.y)*k;
      imgState.x += (mid.x - gesture.lastMid.x)*rect.width*0.7;
      imgState.y += (mid.y - gesture.lastMid.y)*rect.height*0.7;
      gesture.lastMid = mid;
      drawImage();
      scaleEl.textContent = imgState.scale.toFixed(2);
    }
  } else {
    gesture.haveTwo=false; gesture.baseDist=0;
  }

  if(tips.length===1){
    const t=tips[0];
    const pinch = Math.hypot(t.index.x - t.thumb.x, t.index.y - t.thumb.y) < 0.06;
    if(pinch && !gesture.havePinch){
      gesture.havePinch=true; gesture.mid={x:t.index.x,y:t.index.y};
    } else if(pinch && gesture.havePinch){
      const nx=t.index.x, ny=t.index.y;
      imgState.x += (nx-gesture.mid.x)*imgCanvas.width;
      imgState.y += (ny-gesture.mid.y)*imgCanvas.height;
      gesture.mid={x:nx,y:ny};
      drawImage();
    } else { gesture.havePinch=false; }
  }
}

function drawHandHUD(hand){
  const dpr = Math.min(window.devicePixelRatio||1,2);
  const W = hud.width / dpr;
  const H = hud.height / dpr;
  function P(p){ return {x:(1-p.x)*W, y:p.y*H}; }
  hudCtx.strokeStyle='rgba(255,255,255,.12)';
  hudCtx.lineWidth=2;
  const bones=[[0,1,2,3,4],[0,5,6,7,8],[0,9,10,11,12],[0,13,14,15,16],[0,17,18,19,20]];
  bones.forEach(chain=>{
    hudCtx.beginPath();
    chain.forEach((i,j)=>{
      const pt=P(hand[i]);
      if(j===0) hudCtx.moveTo(pt.x,pt.y); else hudCtx.lineTo(pt.x,pt.y);
    });
    hudCtx.stroke();
  });
  [hand[8], hand[4]].forEach(pt=>{
    const p=P(pt);
    const r=10;
    const g=hudCtx.createRadialGradient(p.x,p.y,1,p.x,p.y,r*2);
    g.addColorStop(0,'rgba(122,162,255,.95)'); g.addColorStop(1,'rgba(122,162,255,0)');
    hudCtx.fillStyle=g;
    hudCtx.beginPath(); hudCtx.arc(p.x,p.y,r*2,0,Math.PI*2); hudCtx.fill();
    hudCtx.fillStyle='#fff'; hudCtx.beginPath(); hudCtx.arc(p.x,p.y,4,0,Math.PI*2); hudCtx.fill();
  });
}

/* ====================== 3D Heart module (ESM-friendly) ====================== */
(function addHeartModule(){
  if (window.heart3D) return;
  window.heart3D = { active:false, renderer:null, scene:null, camera:null, controls:null, animId:null, mesh:null, onResize:null };

  function buildHeartMesh(){
    const shape = new THREE.Shape();
    const s=1;
    shape.moveTo(0, 2.5*s);
    shape.bezierCurveTo(-2.5*s, 5*s, -5*s, 2.5*s, -5*s, 0);
    shape.bezierCurveTo(-5*s, -3*s, -2.5*s, -5*s, 0, -3.5*s);
    shape.bezierCurveTo(2.5*s, -5*s, 5*s, -3*s, 5*s, 0);
    shape.bezierCurveTo(5*s, 2.5*s, 2.5*s, 5*s, 0, 2.5*s);

    const extrudeSettings = { depth:2.5, bevelEnabled:true, bevelSegments:6, steps:2, bevelSize:0.6, bevelThickness:0.6 };
    const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    geo.center();
    const mat = new THREE.MeshPhysicalMaterial({ color:0xff3b6b, roughness:0.2, metalness:0.0, clearcoat:0.5, clearcoatRoughness:0.15 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.castShadow = true; mesh.receiveShadow = true;
    return mesh;
  }

  function startHeart(){
    if(window.heart3D.active) return;
    try{
      heartCanvas.style.display = 'block';
      imgCanvas.style.display = 'none';
      rightBadge.textContent = '3D Heart';
      toggleHeartBtn.textContent = 'Show Image';
      resetHeartBtn.style.display = 'inline-block';
      sizeCanvases();
      const rect = heartCanvas.getBoundingClientRect();
      const w = Math.max(2, Math.floor(rect.width));
      const h = Math.max(2, Math.floor(rect.height));
      const renderer = new THREE.WebGLRenderer({ canvas: heartCanvas, antialias:true, alpha:true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setSize(w, h, false);
      renderer.shadowMap.enabled = true;
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x060606);
      const camera = new THREE.PerspectiveCamera(45, Math.max(0.1, w/h), 0.1, 1000);
      camera.position.set(6,5,10);
      const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, 0.7);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 0.9);
      dir.position.set(5,10,7);
      dir.castShadow = true;
      scene.add(dir);
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(100,100), new THREE.ShadowMaterial({opacity:0.25}));
      floor.rotation.x = -Math.PI/2; floor.position.y = -3.2; floor.receiveShadow = true; scene.add(floor);
      const heart = buildHeartMesh(); heart.scale.set(0.8,0.8,0.8); scene.add(heart);
      const controls = new OrbitControls(camera, heartCanvas);
      controls.enableDamping = true; controls.dampingFactor = 0.08; controls.target.set(0,0,0);
      controls.minDistance = 3; controls.maxDistance = 18; controls.enablePan = true;
      function renderLoop(){
        if(window.heart3D && window.heart3D.mesh){ window.heart3D.mesh.rotation.y += 0.004; }
        controls.update();
        renderer.render(scene, camera);
        window.heart3D.animId = requestAnimationFrame(renderLoop);
      }
      window.heart3D.active = true;
      window.heart3D.renderer = renderer;
      window.heart3D.scene = scene;
      window.heart3D.camera = camera;
      window.heart3D.controls = controls;
      window.heart3D.mesh = heart;
      window.heart3D.onResize = function(newW, newH){ try{ if(window.heart3D.renderer && window.heart3D.camera){ window.heart3D.renderer.setSize(Math.max(2,Math.floor(newW)), Math.max(2,Math.floor(newH)), false); window.heart3D.camera.aspect = Math.max(0.1, newW / newH); window.heart3D.camera.updateProjectionMatrix(); } }catch(e){ console.warn('heart resize error', e); } };
      renderLoop();
    }catch(e){ console.error('startHeart failed', e); }
  }

  function stopHeart(){
    if(!window.heart3D || !window.heart3D.active) return;
    try{
      cancelAnimationFrame(window.heart3D.animId);
      if(window.heart3D.controls) window.heart3D.controls.dispose();
      if(window.heart3D.renderer){ try{ const gl = window.heart3D.renderer.getContext && window.heart3D.renderer.getContext(); window.heart3D.renderer.dispose && window.heart3D.renderer.dispose(); if(gl && gl.getExtension && gl.getExtension('WEBGL_lose_context')) gl.getExtension('WEBGL_lose_context').loseContext(); }catch(err){} }
      heartCanvas.style.display = 'none'; imgCanvas.style.display = 'block';
      rightBadge.textContent = 'Image'; toggleHeartBtn.textContent = 'Show 3D Heart'; resetHeartBtn.style.display = 'none';
      window.heart3D = { active:false, renderer:null, scene:null, camera:null, controls:null, animId:null, mesh:null, onResize:null };
    }catch(e){ console.error('stopHeart cleanup error', e); }
  }

  function resetHeart(){ if(!window.heart3D || !window.heart3D.active) return; try{ window.heart3D.camera.position.set(6,5,10); window.heart3D.controls.target.set(0,0,0); window.heart3D.controls.update(); if(window.heart3D.mesh) window.heart3D.mesh.rotation.set(0,0,0); }catch(e){ console.warn('resetHeart error', e); } }

  toggleHeartBtn.addEventListener('click', ()=>{ if(window.heart3D && window.heart3D.active) stopHeart(); else startHeart(); });
  resetHeartBtn.addEventListener('click', resetHeart);
})(); // end addHeartModule

/* ====================== Kickoff ====================== */
(async function init(){
  sizeCanvases();
  const state = (function(){ try{ const src = location.hash?location.hash.slice(1):localStorage.getItem('gz:view'); if(!src) return null; return JSON.parse(decodeURIComponent(escape(atob(src)))); }catch(e){return null;} })();
  if(state && state.scale) Object.assign(imgState, {scale:state.scale, x:state.x, y:state.y});
  drawImage();
  try{ await startCamera(); }catch(e){ console.warn('camera start failed', e); }
  console.log('app ready');
})();

/* ====================== Persist state ====================== */
setInterval(()=> { try{ const enc=btoa(unescape(encodeURIComponent(JSON.stringify({scale:+imgState.scale.toFixed(3), x:+imgState.x.toFixed(1), y:+imgState.y.toFixed(1)})))); if(history.replaceState) history.replaceState(null,'','#'+enc); else localStorage.setItem('gz:view',enc); }catch(e){} }, 1200);
</script>

</body>
</html>
